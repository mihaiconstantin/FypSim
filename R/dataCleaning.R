# Functions responsible with linking design pieces together and
# averaging the values of the indicator across the number of
# design replications. 



#' Function that allows to glue various design pieces together generated by \link{\code{runCellRange}}.
#' The pieces linked together and then averaged across the number of design replications.
#' Can also be used with just one design to obtain the average for the indicators.
#' 
#' @param design (numeric matrix) The configuration of the factorial design that was used. The pieces that
#' will be linked together represent selections from this design matrix. 
#' @param ... (list of raw results) Contains the lists of the raw results as they are returned by \link{\code{runCellRange}} or
#' any other related function.
#' @param saveTo (string) Specifies the location where the averaged matrices of indicators are saved. If \code{NULL} then data
#' is not saved. Defaults to \code{NULL}.
#' 
#' @return Returns a list of matrices representing the averaged indicators across the number of design iterations.
#' First index in the list holds the matrix of detection rates, second the matrix of means, and third the matrix
#' of standard deviations. 
#' 
#' @export
#'
glueDesignPieces <- function(design, ..., saveTo = NULL)
{
	# The design pieces enumarated.
	pieces <- list(...)
	
	# Let's create new variables for each matrix in the list.
	# Then, we merge the data into these variables. The
	# structure is as follows: for each design we 
	# replicated we have the matrix of cells.
	list.detections = list()
	list.means = list()
	list.deviations = list()
	
	
	# Establish the total number of design iterations.
	iterations = length(pieces[[1]])
	
	
	# Go through all the design iterations for all the pieces.
	for(iteration in 1:iterations)
	{
		# Temporary matrices for the current iteration.
		temp.detections = NULL
		temp.means = NULL
		temp.deviations = NULL
		

		for(piece in pieces)
		{
			temp.detections = rbind(temp.detections, piece[[iteration]][[1]])
			temp.means 		= rbind(temp.means,      piece[[iteration]][[2]])
			temp.deviations = rbind(temp.deviations, piece[[iteration]][[3]])
		}
		
		
		# Store the results for the current iteration and start again.
		list.detections[[iteration]] = temp.detections
		list.means[[iteration]]      = temp.means
		list.deviations[[iteration]] = temp.deviations
	}
	
	
	# At this point we have the data for all the replications on all the indicators.
	# Now, it is time to average these values and end up with just three matrices.
	detections = Reduce("+", list.detections) / length(list.detections)
	means      = Reduce("+", list.means) / length(list.means)
	deviations = Reduce("+", list.deviations) / length(list.deviations)
	
	
	# Link the design with each resulted matrixm for easier interpretation.
	detections = cbind(design, detections)
	means = cbind(design, means)
	deviations = cbind(design, deviations)
	
	
	# Let's add some column names for clarity.
	# TODO: make this dynamic... perhaps another time...
	colnames(detections) <- c("s.prop", 
							  "s.magn", 
							  "s.type", 
							  "p.type", 
							  "t.leng",
							  "lvl.1", "lvl.2", "lvl.3", "lvl.4", "lvl.5", "lvl.6", "lvl.7", "lvl.8", "lvl.9")
	
	colnames(means)      <- c("s.prop", 
						      "s.magn", 
						      "s.type", 
						      "p.type", 
						      "t.leng",
						      "lvl.1", "lvl.2", "lvl.3", "lvl.4", "lvl.5", "lvl.6", "lvl.7", "lvl.8", "lvl.9")
	
	colnames(deviations) <- c("s.prop", 
							  "s.magn", 
							  "s.type", 
							  "p.type", 
							  "t.leng",
							  "lvl.1", "lvl.2", "lvl.3", "lvl.4", "lvl.5", "lvl.6", "lvl.7", "lvl.8", "lvl.9")

	
	# Save the data if the user wants to.		
	if(!is.null(saveTo))
	{
		# As .RData
		saveRDS(detections, paste(saveTo, "detection_rates.RData",     sep = ""))
		saveRDS(means,      paste(saveTo, "means.RData",               sep = ""))
		saveRDS(deviations, paste(saveTo, "standard_deviations.RData", sep = ""))
		
		# As .csv
		write.csv(detections, paste(saveTo, "detection_rates.csv",     sep = ""))
		write.csv(means,      paste(saveTo, "means.csv",               sep = ""))
		write.csv(deviations, paste(saveTo, "standard_deviations.csv", sep = ""))
	}
	
	
	# Return the data, just in case.
	return(list(detections, means, deviations))
}


